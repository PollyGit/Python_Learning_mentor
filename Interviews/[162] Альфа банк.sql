1. Среднее считает среднее арифметическое. 1,1,1,1,10 » 7
медиана - наблюдение, которое делит весь набор данных на две равные части:
меньше него 50% наблюдений и больше него тоже 50% наблюдений. 1,1,1,1,10 » 1

2. union - объединяет записи из двух запросов в один общий результат без дубликатов.
union all - с дубликатами.

3  row_number - простая нумерация от 1
rank() - Нумерация с повторами и пропуском рангов , типа 113446

4. Коллега передал вам свой запрос на поддержку,
в последней строке вы видите distributed by (master_id) Нужная строка или удаляем?

Это означает: строки с одинаковым master_id будут физически размещены в одном сегменте (ноде),
что ускоряет JOIN, GROUP BY, и фильтрацию по этому полю.

Если вы работаете в Greenplum/Redshift -» оставить.
Если вы работаете Обычный PostgreSQL, SQLite, MySQL, MS SQL -» удалить, синтаксис не поддерживается.


5. К вам обратился коллега «Сделай выгрузку по продукту X за
отчетный период, как можно быстрее». Витрина по продажам всех продуктов у вас имеется.
Какие будут ваши дальнейшие действия?

Уточнить у коллеги како й именно продукт, по какому полю его идентифицировать,
 четкие даты отчетного периода, какие поля нужны, формат и срочность.

select *
from t
where product = 'x'
    and sales_date between '' and ''

выгрузить через DBeaver и сохранить в нужном формате


6. У вас есть витрина EMPLOYEES, она хранит в себе данные о сотрудниках.
Запись по каждому сотруднику должна быть уникальной.
Напишите код, который поможет Вам найти дубли по полю emp1_id.

select emp1_id
from EMPLOYEES
group by emp1_id
having count(*)>1


7. У вас есть витрина, в которой находятся данные о звонке клиентов
в службу поддержки - CLIENT_HELP. сколько звонков у каждого оператора было за март 2024 года.
Вывод: Оператор, кол-во звонков.

select operator, count(*) as calls_num
from CLIENT_HELP
where date_trunc('month', call_end_dttm) = '2024-03-01'
group by  operator



8. Есть витрина CLIENT_USE, она хранит информации о заходе клиентов на сайт или в приложение.
Напишите код, который даст понять, помог оператор
и смог ли клиент зайти на нужный ему ресурс в течение часа после окончание звонка.
Вывод: Оператор, клиент, помог или нет.

with
t1 as (
    select h.operator, h.client_id, h.call_end_dttm, h.problem,
           u.start_use_dttm, u.resource,
           case
           when u.start_use_dttm <= h.call_end_dttm + INTERVAL '1 hour'
                 and u.resource = h.problem then 1
           else 0
           end as help_ok
    from CLIENT_HELP as h
    left join CLIENT_USE as u
        on h.client_id = u.client_id
            and u.start_use_dttm <= h.call_end_dttm + INTERVAL '1 hour'
)

select client, operator, help_ok
from t1


