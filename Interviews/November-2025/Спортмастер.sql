Задача 1
разница RANK vs DENSE_RANK

select name, score,
    rank() over(order by score desc) as place
from t

--Задача 2
--1.2. Выбор поля для партиционирования таблицы
--по каким принципам вы будете выбирать поле партиционирования

1. Смотреть на объем данных, сколько строк сейчас и сколько добавляется в месяц/день, какой горизонт хранения
2. Кандидаты на ключ партиционирования:
    - время события (`event_time`, `created_at`, `order_date`),
    - география/регион,
    - крупный бизнес-идентификатор (shop_id, tenant_id)
3. Важно, чтобы поле было:
    - неизменяемым,
    - заполненным почти всегда,
    - адекватным по наполнению,
    - распределение значений по этим полям было +- равномерным и партиции имели нормальную кардинальность, те не было такого, чтобы 90% таблицы лежало в 1 партиции
4. как учесть, какие фильтры чаще всего используются в запросах
    - Ключ партиционирования должен почти всегда попадать в WHERE крупных запросов.
    - если по полю практически не фильтруем – оно плохой кандидат.
5. примеры неудачного выбора партиционирования
    - Очень низкая кардинальность (слишком мало значений): всего 2–3 партиции, каждая огромная.
    - Очень высокая кардинальность (слишком много партиций): получим огромное количество партиций
    - Сильный перекос: status = 'ACTIVE' – 95% строк, все остальные статусы – 5%.
    - Партиционирование по «редко используемому» полю, которые почти никогда не используется в WHERE.
    - Партиционирование по полю, которое меняется. Например, партиционирование по `user_status` (`trial` → `paid` → `churned`), при смене статуса строка должна «переехать» в другую партицию.




--Задача 1
--
--EXISTS vs IN
--
--Обсуждается оператор `EXISTS` и его связь с `IN`.
--
--**Задача:**
--
--1. Объяснить, чем принципиально отличается `EXISTS` от `IN` с точки зрения логики и работы оптимизатора.
--2. Привести пример запроса, где предпочтительнее использовать `EXISTS`, а не `IN`.
--3. Пояснить, как ведут себя оба варианта при очень большом списке значений и при наличии `NULL`.


IN (subquery)

- некоррелированный подзапрос
- проверяет «лежит ли значение в наборе значений». Логически: x = v1 OR x = v2 OR ....
- иногда требует DISTINCT, если ты логически хочешь работать с множеством
- Очень большие списки IN (...) могут усложнить парсинг и планирование. Альтернатива: положить эти значения во временную таблицу/CTE и использовать JOIN или EXISTS
- IN чувствителен к NULL в списке (даёт UNKNOWN)
x IN (1, 2, NULL) Если x не равен ни одному из **НЕ-NULL** значений и есть хотя бы один NULL в списке → результат UNKNOWN (то есть NULL, в WHERE такая строка отфильтруется).
- NULL IN (1, 2, NULL) → тоже NULL, т.к. сравнения с NULL дают UNKNOWN.

EXISTS (subquery)

- коррелированный подзапрос
- «есть ли хотя бы одна связанная строка». Вообще не интересуется значениями колонок — только фактом существования.
- Через EXISTS DISTINCT не нужен — дубликаты вторичны.
- Лучше использовать в случаях: поиск строк, для которых **существует хотя бы одна связанная запись**, особенно если нужна ещё логика внутри подзапроса. EXISTS явно говорит: «мне не нужна агрегация / уникальность, просто факт наличия хотя бы одной строки».
- EXISTS смотрит только на строки, где условие истинно, NULL внутри множества его не «ломают`.




t
+------+
|  y   |
+------+
|  1   |
| NULL |
+------+

t2
+------+
|  x   |
+------+
|  5   |
+------+



select *
from t2
where x not in (select y from t);

те where 5 not in (1, NULL) →  UNKNOWN
строка x = 5 пропала (из-за NULL в подзапросе).


select *
from t2 t
where not exists (
    select 1
    from t
    where t.y = t.x
);
→
select 1
from t
where y = 5;

те  y=1 → 1=5 → FALSE
		y=NULL → NULL=5 → UNKNOWN → тоже не берём

 → 0 строк → exists(...) = FALSE → not exists(...) = TRUE.
 строка x = 5 осталась, как и ожидается логически: «5 нет среди значений y».


--
--1.6. Строковые vs колонночные СУБД
 СУБД делятся на **строковые** и **колоночные** по способу хранения данных.
 Строковые (PostgreSQL, MySQL) хранят записи целиком и подходят для транзакций (**OLTP**). Строковые СУБД используют нормализованные таблицы, где активно происходят операции записи, обновления и удаления.
 Колоночные (ClickHouse, Cassandra, Snowflake) хранят данные по столбцам и эффективны для аналитики (**OLAP**), где важны скорость чтения и агрегации и нечасто выполняются операции записи или обновления.
Выбор зависит от того, что важнее — быстро записывать или быстро анализировать данные.








--Задача: объяснить, чем отличаются:
--
--DELETE и TRUNCATE (по поведению, скорости, логированию, возможности отката и т.п.);
DELETE «удалить строки по условию»
TRUNCATE «быстро опустошить таблицу»
--ALTER и UPDATE (что каждый из них делает и в каких сценариях применяется).
UPDATE для изменения значений в существующих строках.
ALTER для изменения структуры таблицы
--