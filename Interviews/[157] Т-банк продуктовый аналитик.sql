--1
--Вы каждый день едете на автомобиле на работу.
--На вашем пути только один светофор, который 2 минуты светит зелёным,
--1 минуту красным.
--Сколько времени вы ожидаемо потеряете при простое на светофоре за 100 поездок?

Р(красный сигнал светофора) = 1/3 ⇒ Но вы приезжаете в случайный момент внутри этой 1 минуты,
поэтому среднее «сколько осталось до зелёного» равно 1/2 минуты (30 секунд).
Р(зеленый сигнал светофора) = 2/3 ⇒ ожидание 0 минут.
Посчитаем Мат ожидание за 1 поездку:
Е[] = 2/3*0 минут ожидания(тк зеленый) + 1/3*0.5(минут ожидания, тк красный) = 1/6=10 секунд
Р = 100 поездок * 10 секунд = 1000 секунд = 16 минут 40 сек



--2
Доверительный интервал - множество возможных значений mu для которых гипотеза не отвергается.

--3

--4
--Как сравнить рост людей в двух популяциях? (t-test)

Наблюдения независимы внутри и между группами. Распределения роста в выборках
 нормальные. Дисперсия неизвестна. Выбросы отсутствуют (или отфильтруем их)

Используем т-тест для проверки гипотез о среднем значении.
Сформулируем гипотезу:
H0 :μ1 =μ2 (средние равны) или μ1 - μ2 = 0.
H1 :μ1 !=μ2 (двусторонняя) или μ1 - μ2 != 0.

Выбираем уровень значимости α. Пусть будет 0.05.
Считаем разность выборочных средних, xˉ1−xˉ2.
Считаем оценку стандартной ошибки ESE.
Считаем t-статистику
Считаем количество степеней свободы.
Считаем p-value.
Сравниваем p-value с уровнем значимости: Если p-value меньше уровня значимости,
принимаем решение, что надо отклонить нулевую гипотезу.Если p-value
больше уровня значимости, оснований отклонить нулевую гипотезу нет.


--5
--Для каждого пользователя в таблице user_logs выберите последнюю запись по полю dttm

select *
from (
select *
    row_number() over(partition by user_id order by dttm desc) as rn
from user_logs) as t
where rn = 1

--6
--Напишите запрос, который выводит для каждого пользователя и даты из calendar сумму его последнего заказа.
--В случае если дата, меньше даты первого заказа, то такая строка не попадает в
--результат запроса.
--
--calendar - календарь с датами и метаинформацией: calendar_dt, holiday_flag, month_num
--
--orders - заказы пользователей: order_day, user_id, order_sum

with
t as (
    select c.calendar_dt, o.user_id, o.order_day, o.order_sum,
            max(o.order_day) over (partition by o.user_id, c.calendar_dt
                                   order by o.order_day
                                   rows between unbounded preceding and current row
        ) as last_order_day
    from calendar c
    join orders o
        on o.order_day <= c.calendar_dt
)

select calendar_dt, user_id, order_sum
from t
where order_day = last_order_day
order by user_id, calendar_dt;
















