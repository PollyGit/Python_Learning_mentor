import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# Генерация случайных данных
np.random.seed(42)
n_rows = 1000

product_names = ["Ноутбук", "Смартфон", "Планшет", "Наушники", "Клавиатура", "Мышь", "Монитор", "Часы", "Колонка", "Флешка"]
categories = ["Электроника", "Аксессуары", "Гаджеты"]
customer_names = ["Иванов", "Петров", "Сидоров", "Кузнецов", "Смирнов", "Васильев", "Морозов", "Павлов", "Фёдоров", "Белов"]

sales_data = {
    "order_id": np.arange(1, n_rows + 1),
    "customer_name": np.random.choice(customer_names, n_rows),
    "product": np.random.choice(product_names, n_rows),
    "category": np.random.choice(categories, n_rows),
    "price": np.random.randint(500, 50000, n_rows),
    "quantity": np.random.randint(1, 5, n_rows),
    "order_date": [datetime.today() - timedelta(days=np.random.randint(1, 365)) for _ in range(n_rows)],
    "rating": np.round(np.random.uniform(1, 5, n_rows), 1),
}

df = pd.DataFrame(sales_data)
print(df.iloc[0:8].head(5))

customers = pd.DataFrame({
    "customer_name": customer_names,
    "city": ["Москва", "СПб", "Новосибирск", "Екатеринбург", "Казань",
             "Челябинск", "Омск", "Самара", "Ростов", "Уфа"]
})


# 1. Вывести 5 первых строк датасета.
print(df.iloc[0:5])

# 2. Определить количество уникальных товаров.
#uniq_products = df.product.nunique()
# df.product может конфликтовать с встроенным методом DataFrame.product()
# — это метод для перемножения значений

uniq_products = df['product'].nunique()
print(uniq_products)

# 3. Подсчитать количество заказов по каждому товару.
n_orders = df['product'].value_counts()
print(n_orders)

# 4. Найти товар с наибольшим количеством заказов.
print('наибольшее количество заказов:  ', n_orders.max())
print('товар с наибольшим количеством заказов:  ', n_orders.idxmax())


# 5. Найти среднюю цену каждого товара.
print('Найти среднюю цену каждого товара \n' , df.groupby('product')['price'].mean())

# 6. Вывести топ-5 самых дорогих товаров по средней цене.
mean_price = df.groupby('product')['price'].mean()
print('Вывести топ-5 самых дорогих товаров по средней цене \n', mean_price.sort_values(ascending=False).head(5))

# or: решение
print(df.groupby("product")["price"].mean().nlargest(5))

# 7. Найти суммарную выручку по каждому товару.
df["total_spent"] = df["price"] * df["quantity"]
print('7. Найти суммарную выручку по каждому товару \n', df.groupby('product')['total_spent'].sum())

# 8. Найти самый прибыльный товар.
print('8. Найти самый прибыльный товар \n', df.groupby('product')['total_spent'].sum().idxmax())

# 9. Определить, сколько заказов сделал каждый клиент.
print('9. Определить, сколько заказов сделал каждый клиент \n', df["customer_name"].value_counts())

# 10. Найти клиента, совершившего больше всего заказов.
print('10. Найти клиента, совершившего больше всего заказов \n', df["customer_name"].value_counts().idxmax())

# 11. Определить, какой клиент потратил больше всего денег.
df["total_spent"] = df["price"] * df["quantity"]
top_customer = df.groupby('customer_name')['total_spent'].sum().idxmax()
print('11. Определить, какой клиент потратил больше всего денег.\n', top_customer)

# 12. Определить средний чек заказа.
print('12. Определить средний чек заказа \n', round(df["total_spent"].mean(), 2))

# 13. Найти общее количество проданных товаров.
print('13. Найти общее количество проданных товаров \n', df['quantity'].sum() )

# 14. Определить товар с наибольшим общим количеством продаж.
print('14. Определить товар с наибольшим общим количеством продаж\n', df.groupby('product')['quantity'].sum().idxmax())

# 15. Найти средний рейтинг товаров.
print('\n',  )
print('15. Найти средний рейтинг товаров\n', df.groupby('product')['rating'].mean())
print('15. Найти средний рейтинг товаров\n', round(df["rating"].mean(), 2))


# 16. Определить, какой товар имеет самый высокий средний рейтинг.
print('16. Определить, какой товар имеет самый высокий средний рейтинг \n', df.groupby('product')['rating'].mean().idxmax())


# 17. Определить, какой товар имеет самый низкий средний рейтинг.
print('16. Определить, какой товар имеет самый низкий средний рейтинг \n', df.groupby('product')['rating'].mean().idxmin())


# 18. Найти процент товаров с рейтингом ниже 3.
avg_rating = df.groupby('product')['rating'].mean()
print('18. Найти процент товаров с рейтингом ниже 3\n', (df[df["rating"] < 3].shape[0] / df.shape[0]) * 100)
print('\n',  )

# 19. Определить день недели с наибольшим количеством заказов.
# Добавляем столбец с названием дня недели
df["weekday"] = df["order_date"].dt.day_name()
сount_orders = df["weekday"].value_counts()
print('19. Определить день недели с наибольшим количеством заказов \n', сount_orders.idxmax())

# 20. Определить, в каком месяце было больше всего заказов.
df["month"] = df["order_date"].dt.month_name()
print('20. Определить, в каком месяце было больше всего заказов\n', df["month"].value_counts().idxmax() )

# 21. Подсчитать количество заказов по дням недели.
# 22. Найти количество заказов по месяцам.
# 23. Определить средний рейтинг товаров по категориям.
# 24. Найти топ-3 клиентов с наибольшей суммой заказов.
# 25. Определить среднее количество товаров в заказе.
# 26. Найти процент заказов с более чем 3 товарами.
# 27. Определить, сколько заказов было сделано за последние 30 дней.
# 28. Найти день с наибольшей выручкой.
# 29. Определить месяц с наибольшей выручкой.
# 30. Найти самый популярный товар в каждом месяце.
# 31. Добавить таблицу с городами клиентов и объединить её с основным DataFrame по имени клиента.
# 32. Объединить таблицу со средним рейтингом товара по названию продукта.
# 33. Найти клиентов, которые заказывали только один уникальный товар, и объединить с основным DataFrame.
# 34. Получить описательную статистику по всем числовым столбцам основного DataFrame.
# 35. Получить описательную статистику по цене и количеству в разрезе категорий.
# 36. Найти товары с наибольшим средним чеком (цена × количество).
# 37. Построить корреляционную матрицу для всех числовых столбцов.
# 38. Найти три признака с наибольшей корреляцией по модулю с total (цена × количество).
# 39. Вычислить корреляцию между количеством (quantity) и рейтингом (rating).
# 40. Визуализировать тепловую карту корреляций с помощью seaborn.